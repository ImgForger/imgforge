# Introduction

imgforge is a fast, secure image proxy and transformation server built in Rust on top of libvips and Axum. It sits between your applications, a CDN, and the original image storage to resize, crop, convert formats, apply effects, and cache results on the fly.

- Performance-first: libvips and an async architecture deliver low latency and high throughput.
- Safe by default: signed URLs, optional bearer auth, and strict guards protect your origins.
- Operationally ready: metrics, structured logs, health endpoints, and predictable resource use.
- Familiar semantics: URL format is largely compatible with imgproxy, easing migrations.

## What problems imgforge solves

- Resize, crop, and convert images on demand without pre-generating variants.
- Reduce bandwidth and speed up pages by delivering modern formats (WebP/AVIF/HEIC) and right-sized images.
- Offload image IO and processing from your app servers to a dedicated service.
- Front a slow or rate-limited origin with a cacheable, CDN-friendly image layer.

## High-level architecture

1. A client requests a transformation URL (usually generated by your app).
2. imgforge verifies the HMAC signature derived from `IMGFORGE_KEY` and `IMGFORGE_SALT` (unless explicitly allowed to use `unsafe`).
3. The server downloads the source image with size and MIME checks.
4. libvips applies the requested operations (resize, crop, blur/sharpen, watermarking, format conversion, etc.).
5. Results are served and optionally cached (memory, disk, or hybrid) for reuse.

See the request flow and processing details:
- Request lifecycle: doc/6_request_lifecycle.md
- Image processing pipeline: doc/12_image_processing_pipeline.md

## Running imgforge

The recommended way to run imgforge is the published container image from GitHub Container Registry.

```bash
docker pull ghcr.io/imgforger/imgforge:latest

docker run --rm -p 3000:3000 \
  -e IMGFORGE_KEY=$(openssl rand -hex 32) \
  -e IMGFORGE_SALT=$(openssl rand -hex 32) \
  ghcr.io/imgforger/imgforge:latest
```

- Quick start: doc/2_quick_start.md
- Installation options (native and container): doc/1_installation.md
- Deployment guidance: doc/10_deployment.md

## Security model at a glance

- HMAC-signed URLs are required by default; disable only for local development with `IMGFORGE_ALLOW_UNSIGNED=true`.
- Optional bearer authentication via `IMGFORGE_SECRET` for `/info` and processing endpoints.
- Inbound fetch safeguards: allowed MIME types, maximum source size, and pixel resolution caps.
- Rate limiting and per-request guards stop abuse before it reaches your origin.

## Caching and performance

- Pluggable caches (memory, disk, or hybrid via Foyer) reduce repeated work.
- DPR-aware rendering and format negotiation minimize bytes on the wire.
- Tunable concurrency controls keep tail latencies predictable under load.

## What imgforge is not

- A general file server or CDN by itself. Pair it with a CDN or reverse proxy for TLS, caching, and global distribution.
- A digital asset management system. Use your existing storage and pipelines; imgforge focuses on transformation and delivery.

## Migrating from imgproxy

imgforge aims to be compatible with common imgproxy URL patterns. Most existing builders will work without changes. Review:
- URL structure and signing: doc/4_url_structure.md
- Processing options: doc/5_processing_options.md

## Next steps

- Try your first request: doc/2_quick_start.md
- Explore configuration: doc/3_configuration.md
- Set up monitoring: doc/11_prometheus_monitoring.md
